** Hector Barriguete
- Documentaci√≥n :: [[./BarrigueteHector/tarea#2.pdf][tarea#2.pdf]]
- Archivos :: [[./BarrigueteHector/balsa.py][balsa.py]]
- Problema resuelto :: El cruce del r√≠o
- Comentarios ::
  - Lograste cumplir con los requisitos, pero lo hiciste /serializando
    la ejecuci√≥n/ del programa ‚òπ
    - Si lo primero que haces al entrar a tu funci√≥n =pasajero(id)= es
      =mutex.acquire()=, y lo √∫ltimo que haces al salir de la misma es
      =mutex.release()=, para fines pr√°cticos est√°s trabajando con un
      √∫nico hilo (no hay trabajo en paralelo ‚òπ)
  - No considero que esta sea una respuesta v√°lida empleando
    mecanismos de sincronizaci√≥n, pero te doy cr√©dito por hacer un
    intento funcional.
- Calificaci√≥n :: 7.5

** Erick Mendez, Carla Rodriguez
- Documentaci√≥n :: [[./MendezErick-RodriguezCarla/tarea2.txt][tarea2.txt]], [[./MendezErick-RodriguezCarla/tarea2_EjercicioSincronizacion.txt][tarea2_EjercicioSincronizacion.txt]]
- Archivos :: [[./MendezErick-RodriguezCarla/cruzando_el_r√≠o.py][cruzando_el_r√≠o.py]]
- Problema resuelto :: El cruce del r√≠o
- Comentarios ::
  - La l√≥gica que siguen es correcta. ¬°Y no se preocupen! Modelar
    correctamente la interacci√≥n de este problema... suena m√°s
    sencillo de lo que es en realidad.
  - ¬øPor qu√© lanzan 4 hackers y /7/ serfs? Necesariamente se quedan
    tres esperando para siempre a que llegue su √∫ltimo amiguito ‚òπ
    - Lo cambi√© a 8 y 8, y funciona correctamente
  - La demora que introdujeron al principio estaaba en el lugar
    equivocado: Al poner el =time.sleep(random.randint(0,2))= en el
    ciclo de lanzamiento de hilos =serf=, los =hack= sal√≠an todos
    ordenaditos antes de que los =serfs= llegaran. Pero si movemos la
    demora para que quede como primera l√≠nea tanto de =hacker(id)=
    como de =serf(id)=, la interacci√≥n se presenta bien:
    #+begin_src python
      Hacker 2 esperando
      Subo a la balsa soy hack 2
      Subo a la balsa soy hack 3
      Serf 5 esperando
      Subo a la balsa soy serf 5
      Subo a la balsa soy serf 2
      Adios, zarpamos
      Adios, zarpamos
      Adios, zarpamos
      Adios, zarpamos
    #+end_src
    üòÉ
- Calificaci√≥n :: 10

** Jesus Fajardo
- Documentaci√≥n :: [[./FajardoJesus/Tarea2.txt][Tarea2.txt]]
- Archivos :: [[./FajardoJesus/Tarea2.py][Tarea2.py]]
- Problema resuelto :: El cruce del r√≠o
- Comentarios ::
  - ¬°Pero qu√© impacientes tus hilos! Cuando uno de tus hilos no puede
    subir, no se duerme para esperar su turno: Simplemente se va ‚òπ
    - Eso suena a una tarea para... ¬°M√°s sincronizaci√≥n! üòâ)
  - Como lo menciona tu documentaci√≥n, tu c√≥digo est√° basado en el
    manejo de mutex+multiplex. Sin embargo:
    - Acceso no protegido a variables compartidas en la comparaci√≥n
      con la que decides si cada hilo puede subir o no (¬°condici√≥n de
      carrera!)
    - La l√≥gica del control de acceso a la balsa est√° manejada por un
      =if=, est√°s usando l√≥gica secuencial.
  - Ojo, lo que manejas como =barrera= /no es/ una barrera, sino que
    un mutex
    - ¬°Oh! Entonces tengo que cambiar lo que escrib√≠ arriba (pero lo
      dejo como... evidencia de mi l√≥gica al leer tu c√≥digo üòâ): Si
      bien lanzas los 12 hilos, este mutex /serializa su
      ejecuci√≥n/. No vas a tener condiciones de carrera, pero no vas a
      aprovechar la concurrencia, porque √∫nicamente un hilo
      (indistinto si es =Hacker()= o =Serf()=) est√°r√° activo al mismo
      tiempo.
- Calificaci√≥n :: 7.5

** Alan M√©ndez
- Documentaci√≥n :: [[./MendezAlan/T02.txt]]
- Archivos :: [[./MendezAlan/T02Balsa.py][T02Balsa.py]]
- Problema resuelto :: El cruce del r√≠o
- Comentarios ::
  - ¬°Muy bien! Me parece que tu ejemplo es el que m√°s se acerca a lo
    m√°s sencillo posible empleando √∫nicamente mecanismos de
    sincronizaci√≥n.
  - Me parece curiosa la caracterizaci√≥n que haces: Lanzas
    =numHackers + numSerfs= desarrolladores, que se pasan toda la vida
    llegando a la balsa (por el mismo lado) y cruzando el r√≠o hacia el
    congreso (recuerda que la balsa /retorna solita/). Pero tu c√≥digo
    funciona bien incluso retirando ese =while True=.
  - Respecto a tu pregunta: Bueno, lo m√°s sencillo y /simplote/ es
    simplemente mandar una /bit√°cora de acciones/ a consola, con
    =print()=. Pero el embellecimiento est√° limitado √∫nicamente por tu
    imaginaci√≥n.
    - Puedes ayudarte coloreando las l√≠neas de la salida, escribiendo
      directamente los c√≥digos ANSI, o mejor a√∫n, con m√≥dulos como
      =colorama=:
      #+begin_src python
	from colorama import Fore,Back,Style
	print("Ac√° todo est√°", Fore.GREEN, Back.BLUE, "bien y bonito", Style.RESET_ALL, ".")
      #+end_src
    - Puedes dibujar un "mapa" de la situaci√≥n que est√°s
      describiendo. Una de las bibliotecas m√°s completas para esto es
      =curses=; te permite direccionar sobre la terminal a partir de
      coordenadas, dibujar, obtener interactividad mediante el teclado
      y el mouse... Pero es un poco complicadito. Te dejo √∫nicamente
      la [[https://docs.python.org/3/howto/curses.html][liga a un tutorial b√°sico]]. Hay varios m√°s, como
      [[https://pythonawesome.com/a-simple-yet-powerful-tui-framework-for-your-python-3-7-applications/][pytermgui]]. Y... bueno, puedes seguir busc√°ndole desde ah√≠ üòâ
    - O por otro lado, ¬øpor qu√© no hacer una aplicaci√≥n gr√°fica
      completa? No es dif√≠cil, aunque s√≠ un poco laborioso. Y claro,
      hay tambi√©n todo tipo de bibliotecas disponibles: [[https://docs.python.org/3/library/tk.html][Tk]], [[https://python-gtk-3-tutorial.readthedocs.io/en/latest/][Gtk]], [[https://pythonpyqt.com/][Qt]],
      [[https://doc.qt.io/qtforpython/gettingstarted.html][wxPython]], y puedo asegurarte que muchas m√°s.
- Calificaci√≥n :: 10

** Issac Alexander Guerrero Prado
- Archivos :: [[./GuerreroPradoIssacAlexander/tarea2.py][tarea2.py]]
- Problema resuelto :: Gatos y ratones
- Comentarios ::
  - ¬°Buena implementaci√≥n! Cortita, al grano y completa.
- Calificaci√≥n :: 10

** Mar√≠a Mu√±oz, Esteban Tafolla
- Documentaci√≥n :: [[./Mu√±ozMar√≠a-TafollaEsteban/Tarea2.txt][Tarea2.txt]]
- Archivos :: [[./Mu√±ozMar√≠a-TafollaEsteban/gatos_ratones.py][gatos_ratones.py]]
- Problema resuelto :: Gatos y ratones
- Comentarios ::
  - El programa funciona bien, aunque me pongo a revisarlo (porque el
    √≠ndice de mortandad de los ratones es demasiado elevado ‚òπ ¬°No
    deber√≠an morirse tan seguido!)
  - Me parece que cayeron en /sobre-ingenier√≠a/ para su proyecto
    - Tiene tal vez /demasiadas/ construcciones de sincronizaci√≥n,
      algunas de ellas duplicando su prop√≥sito:
      #+begin_src python
	mutex = threading.Semaphore(1) # Protege a la variable ratones
	mutex2 = threading.Semaphore(1) # Protege a la variable gatos
	mutex_muerte = threading.Semaphore(0) # Permite a los ratones valientes morir :c

	# (...)
	def raton(id):
	    # (...)
	    mutex2.acquire()
	    if gatos > 0 :
		mutex_muerte.acquire()
		muerte(id)
		mutex_muerte.release()
		mutex2.release()
		multiplex_platos.release()
		return
	    mutex2.release()
	    # (...)

	# (...)
	def muerte(id):
	    global ratones
	    print("Un gato mat√≥ al ratoncito", id,":(")
	    mutex.acquire()
	    ratones = ratones - 1
	    if ratones == 0:
		cuarto_con_ratones.release()
	    mutex.release()
      #+end_src
      Siempre que modifican =ratones= lo hacen protegi√©ndolo con
      =mutex= ‚áí Me parece que =mutex_muerte= es innecesario.
    - ... Y no termino de entender por qu√© en =comeGato()= liberan y
      adquieren a =mutex_muerte=, en una suerte de /anti-mutex/ (¬ø?)
  - Me llama la atenci√≥n que el que verifica /si debe ser comido/ es
    =raton()=, no es =gato()= el que revisa si hay alg√∫n =raton()=
    para com√©rselo.
    - Est√° bien, se ajusta a las especificaciones del programa... Pero
      en general, para los programas que desarrollen, ¬°procuren que
      quien emprenda las acciones sea el actor definido! (o empleen
      /representantes/proxies/ para tal fin). Esto por claridad y
      mantenibilidad del c√≥digo.
- Calificaci√≥n :: 9


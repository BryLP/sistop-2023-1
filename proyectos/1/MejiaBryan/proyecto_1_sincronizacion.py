# -*- coding: utf-8 -*-
"""Proyecto 1 - Sincronizacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rEufTdrs5tJCLRx3m0i4KxPkmKpURU95
"""

#Proyecto 1 - Sincronizacion - Mejia Ramos Bryan

import threading
from threading import Semaphore, Thread
import random

#Variables adicionales
numSpace = 4                                                                    #Se utilizara para formar un mapa cuadrado
numPlay = 4                                                                     #Numero de hilos/jugadores
barreraParaJugar = Semaphore(0)
mutexDatos = Semaphore(1)
mutexPrint = Semaphore(1)

#Datos compartidos
mapaJuegoProteccion = [Semaphore(1) for i in range(0,(numSpace*numSpace))]      #Lista de semaforos para representar las posiciones en el mapa
mapaJuego = [[]]*numSpace                                                       #Lista numerica para representar las zonas pintadas
jugadores = 0
jugadores2 = 0

#Mapa dinamico
for i in range(0,numSpace):                                                     #Crea el mapa, una lista de 0 con el tama√±o de numSpace en cada lado
  listaCero = [0]*numSpace
  mapaJuego[i] = mapaJuego[i] + listaCero


def printmapa():                                                                #Funcion que imprime nuestro mapa de juego
    print("")
    print("\033[1;36m"+str(mapaJuego[0]))
    print(mapaJuego[1])
    print(mapaJuego[2])
    print(mapaJuego[3])
    print("")

def contarPuntos(mapaJuego):                                                    #Funcion que facilita el conteo de los puntos en base a las zonas pintadas por los jugadores
  global numPlay, numSpace
  puntos= 0
  puntajes = []
  
  for j in range(1,numPlay+1):                                                  #Funcion que recorre y cuenta los valores de la lista y los almacena...
    for i in range(0,numSpace):
      puntos += mapaJuego[i].count(j)
    puntajes.append(puntos)                                                     #En otra lista, respetando el orden relativo
    puntos = 0
  
  for i in range(0,numPlay):                                                    #Compara el mayro puntaje con la lista de donde se obtuvo, para conocer el numero de hilo ganador
    if max(puntajes) == puntajes[i]:  
      print("\033[1;35m"+"El ganador es Hilo: "+str(i+1)+ " con "+str(max(puntajes))+" puntos !")
       

def player(id):
  global jugadores, jugadores2

  #Incia sala de espera
  mutexDatos.acquire()
  print("\033[1;32m"+"Esperando jugadores...")
  jugadores+= 1
  if jugadores == numPlay:                                                      #Para que todos los jugadores entren al mismo tiempo, usamos una barrera
    barreraParaJugar.release()
    print("\033[1;34m"+"Listo, pueden jugar!")
  mutexDatos.release()
  
  barreraParaJugar.acquire()
  barreraParaJugar.release()

  #Inicia el juego
  mutexPrint.acquire()                                                          #Impresion del mapa vacio
  printmapa()
  mutexPrint.release()
  
  posicionI = random.randint(0,numSpace*numSpace-1)                             #Se coloca en una posicion random en el tablero
  
  mutexPrint.acquire()
  print("\033[1;32m"+str(id)+": Posicion incial = "+str(posicionI))
  mutexPrint.release()

  mutexDatos.acquire()
  mapaJuegoProteccion[posicionI].acquire()                                      #Adquiere su posicion actual
  mapaJuego[int(posicionI/(numSpace))][int(posicionI%(numSpace))] = id          #"Pinta" sus posicion actual con su Id
  mapaJuegoProteccion[posicionI].release()
  mutexDatos.release()
  
  mutexPrint.acquire()
  printmapa()                                                                   #Impersion de la primera posicion de los jugadores
  mutexPrint.release()

  #Se mueve a...
  for i in range(200):
    direccion = random.randint(0,3)
    
    if (direccion == 0): #Arriba
      if posicionI-4 <16 and posicionI-4 >= 0:                                  #Verifica que no se sale del mapa al avanzar hacia adelante
        mutexDatos.acquire()
        mapaJuegoProteccion[posicionI].release()                                #"Suelta" la posicion en la que se encontraba
        
        posicionI = posicionI - 4
        mapaJuegoProteccion[posicionI].acquire()                                #Adquiere nueva posicion
        mapaJuego[int(posicionI/(numSpace))][int(posicionI%(numSpace))] = id    #Pinta su nuevo lugar en el mapa
        
        mapaJuegoProteccion[posicionI].release()
        mutexDatos.release()

    if (direccion == 1): #Izquierda
      if int(posicionI%numSpace) == 1 or int(posicionI%numSpace) == 2:          #Verifica que no se sale del mapa cuando intenta moverse a la izquierda
        mutexDatos.acquire()
        mapaJuegoProteccion[posicionI].release()                                #"Suelta" la posicion en la que se encontraba
        
        posicionI = posicionI - 1
        mapaJuegoProteccion[posicionI].acquire()                                #Adquiere nueva posicion
        mapaJuego[int(posicionI/(numSpace))][int(posicionI%(numSpace))] = id    #Pinta su nuevo lugar en el mapa
        
        mapaJuegoProteccion[posicionI].release()
        mutexDatos.release()

    if (direccion == 2): #Abajo
      if posicionI+4 <16 and posicionI+4 >= 0:                                  #Verifica que no se sale del mapa al avanzar hacia atras 
        mutexDatos.acquire()
        mapaJuegoProteccion[posicionI].release()                                #"Suelta" la posicion en la que se encontraba
        
        posicionI = posicionI + 4
        mapaJuegoProteccion[posicionI].acquire()                                #Adquiere nueva posicion
        mapaJuego[int(posicionI/(numSpace))][int(posicionI%(numSpace))] = id    #Pinta su nuevo lugar en el mapa
        
        mapaJuegoProteccion[posicionI].release()
        mutexDatos.release()

    if (direccion == 3): #Derecha
      if int(posicionI%numSpace) == 1 or int(posicionI%numSpace) == 2:          #Verifica que no se sale del mapa cuando intenta moverse a la derecha
        mutexDatos.acquire()                
        mapaJuegoProteccion[posicionI].release()                                #"Suelta" la posicion en la que se encontraba
        
        posicionI = posicionI + 1
        mapaJuegoProteccion[posicionI].acquire()                                #Adquiere nueva posicion
        mapaJuego[int(posicionI/(numSpace))][int(posicionI%(numSpace))] = id    #Pinta su nuevo lugar en el mapa
        
        mapaJuegoProteccion[posicionI].release()
        mutexDatos.release()

  #Impresion del mapa sin interrupcion de otros prints (se imprime por cada hilo)
  mutexPrint.acquire()
  printmapa()
  mutexPrint.release()

#Barrera final
  mutexDatos.acquire()
  print("\033[1;31m"+str(id)+": Termino sus movimientos")
  jugadores2+= 1
  if jugadores2 == numPlay:                                                     #Todos los jugadores se esperan para terminar la partida
    barreraParaJugar.release()
    contarPuntos(mapaJuego)                                                     #Imprime ganador en base a las zonas pintadas en el mapa
  mutexDatos.release()
  
  barreraParaJugar.acquire()
  barreraParaJugar.release()

#Creacion de jugadores
JugadoresHilos = [threading.Thread(target=player,args=[i]).start() for i in range(1,numPlay+1)]

mapaJuego = [[1,2,3,4],[4,3,2,2]]